# SpinePrep Snakefile: validate + discover + mppca + motion + confounds smoke
import json
import os
import subprocess
from pathlib import Path

from workflow.lib.samples import first_row, rows, row_by_id  # type: ignore

CFG_PATH = os.environ.get("SPINEPREP_CONFIG", "configs/study.yaml")
CFG_SCHEMA = "schemas/config.schema.json" if Path("schemas/config.schema.json").exists() else None

def _load():
    from spineprep.config import load_config
    return load_config(CFG_PATH, CFG_SCHEMA)

CFG = _load()
BIDS = CFG["paths"]["bids_dir"]
DERIV = CFG["paths"]["deriv_dir"]
LOGS = CFG["paths"]["logs_dir"]
Path(LOGS).mkdir(parents=True, exist_ok=True)

SAMPLES = f"{LOGS}/samples.tsv"
SAMPLE_ROWS = rows(SAMPLES)  # list of dicts
N = len(SAMPLE_ROWS)

rule all:
    input:
        f"{LOGS}/validate.ok",
        f"{LOGS}/discover.json",
        f"{LOGS}/samples.tsv",
        "preproc_all",  # aggregate target

rule validate_config:
    output:
        ok = f"{LOGS}/validate.ok"
    run:
        from spineprep.config import load_config
        load_config(CFG_PATH, CFG_SCHEMA)
        Path(output.ok).write_text("ok\n")

rule discover:
    input:
        ok = rules.validate_config.output.ok
    output:
        out = f"{LOGS}/discover.json"
    run:
        from spineprep.config import load_config
        from spineprep.adapters.bids import discover
        cfg = load_config(CFG_PATH, CFG_SCHEMA)
        summary = discover(cfg["paths"]["bids_dir"])
        Path(output.out).write_text(json.dumps(summary, indent=2))
        print("Subjects:", summary["counts"]["subjects"], "Runs:", summary["counts"]["runs"])

rule samples:
    input:
        disc = rules.discover.output.out
    output:
        tsv = f"{LOGS}/samples.tsv"
    run:
        from workflow.lib.samples import build_samples  # type: ignore
        n = build_samples(input.disc, BIDS, output.tsv)
        print(f"Wrote samples.tsv with {n} rows")

rule preproc_all:
    input:
        expand("confounds_{id}.tsv", id=range(N)),
        expand("confounds_{id}.json", id=range(N))

# Per-run MP-PCA
rule mppca:
    output:
        o = "mppca_{id}.ok"
    run:
        import os, subprocess
        r = row_by_id(SAMPLES, int(wildcards.id))
        env = os.environ.copy()
        env["IN_BOLD"] = r["bold_path"]
        env["DENOISE_MPPCA"] = "1" if CFG.get("options", {}).get("denoise_mppca", False) else "0"
        Path("steps/spi05_mppca.sh").chmod(0o755)
        subprocess.run(["bash", "steps/spi05_mppca.sh"], check=True, env=env)
        Path(output.o).write_text("ok\n")

# Per-run motion (depends on mppca output or falls back)
rule motion:
    input:
        mppca = "mppca_{id}.ok"
    output:
        o = "motion_{id}.ok"
    run:
        import os, subprocess
        from pathlib import Path as _P
        r = row_by_id(SAMPLES, int(wildcards.id))
        in_bold = r["mppca_path"]
        if not _P(in_bold).exists():
            in_bold = r["bold_path"]
        env = os.environ.copy()
        env["IN_BOLD"] = in_bold
        env["MOTION_ENABLE"] = "1"
        Path("steps/spi06_motion.sh").chmod(0o755)
        subprocess.run(["bash", "steps/spi06_motion.sh"], check=True, env=env)
        Path(output.o).write_text("ok\n")

# Per-run confounds (depends on motion output or falls back)
rule confounds:
    input:
        motion = "motion_{id}.ok"
    output:
        tsv  = "confounds_{id}.tsv",
        json = "confounds_{id}.json"
    run:
        import os, subprocess
        from pathlib import Path as _P
        r = row_by_id(SAMPLES, int(wildcards.id))
        in_bold = r["motion_path"]
        if not _P(in_bold).exists():
            in_bold = r["bold_path"]
        env = os.environ.copy()
        env["IN_BOLD"] = in_bold
        env["TR_S"] = str(CFG.get("acq", {}).get("tr", 1.0))
        Path("steps/spi07_confounds.sh").chmod(0o755)
        subprocess.run(["bash", "steps/spi07_confounds.sh"], check=True, env=env)
        # Create placeholder outputs to satisfy Snakemake
        Path(output.tsv).write_text("placeholder\n")
        Path(output.json).write_text('{"placeholder": true}\n')

# deprecated: use per-run rules
rule mppca_smoke:
    input:
        disc = rules.discover.output.out
    output:
        mark = f"{LOGS}/mppca_smoke.ok"
    run:
        import os, subprocess
        row = first_row(SAMPLES)
        in_bold = row["bold_path"]
        env = os.environ.copy()
        env["IN_BOLD"] = in_bold
        env["DENOISE_MPPCA"] = "1" if CFG.get("options", {}).get("denoise_mppca", False) else "0"
        Path("steps/spi05_mppca.sh").chmod(0o755)
        subprocess.run(["bash", "steps/spi05_mppca.sh"], check=True, env=env)
        Path(output.mark).write_text("ok\n")

rule motion_smoke:
    input:
        disc = rules.discover.output.out,
        prev = rules.mppca_smoke.output.mark
    output:
        mark = f"{LOGS}/motion_smoke.ok"
    run:
        import os, subprocess
        from pathlib import Path as _P
        row = first_row(SAMPLES)
        in_bold = row["mppca_path"]
        if not _P(in_bold).exists():
            in_bold = row["bold_path"]
        env = os.environ.copy()
        env["IN_BOLD"] = in_bold
        env["MOTION_ENABLE"] = "1"
        Path("steps/spi06_motion.sh").chmod(0o755)
        subprocess.run(["bash", "steps/spi06_motion.sh"], check=True, env=env)
        Path(output.mark).write_text("ok\n")

rule confounds_smoke:
    input:
        prev = rules.motion_smoke.output.mark
    output:
        mark = f"{LOGS}/confounds_smoke.ok"
    run:
        import os, subprocess
        from pathlib import Path as _P
        row = first_row(SAMPLES)
        in_bold = row["motion_path"]
        if not _P(in_bold).exists():
            in_bold = row["bold_path"]
        env = os.environ.copy()
        env["IN_BOLD"] = in_bold
        env["TR_S"] = str(CFG.get("acq", {}).get("tr", 1.0))
        Path("steps/spi07_confounds.sh").chmod(0o755)
        subprocess.run(["bash", "steps/spi07_confounds.sh"], check=True, env=env)
        Path(output.mark).write_text("ok\n")
